


#### **Théorie**
https://axcheron.github.io/exploit-101-format-strings/#precision-write
- Dans les fonctions tel que printf qui utilise des spécificateur de chaine de format, si l'utilisateur contrôle l'argument, on peut plus ou moins faire ce qu'on veut. 
- En effet, si dans le texte de printf() par exemple, il y a trop de spécificateur pour le peu d'arguments qu'on y passe, il va quand même lire les emplacement qui suivent les arguments présent. Il va donc lire des emplacement mémoire qui ne sont pas vraiment des arguments.

- **Protection**
	- La bonne façon de print une variable c'est de faire :
		- `printf("%s", buf)` car %s ne va rien interpréter.
	- Utilisation de canary ?
#### **Pratique**

##### **Exploit 1**

- **Environnement**
	- On doit pouvoir contrôler la valeur des arguments. 
	- Pas d'ASLR, pas de canary, pas de stack-protection enfin rien quoi c'est juste une template d'exploitation, une théorie

- **Code source**
```C
#include <stdio.h>
#include <string.h>
int main(int argc, char** argv){
	int target = 0;
	printf(argv[1]);
}
```
- **Analyse du code source**
	- En fait, quand on va appeler printf(), ça va créer une stack sur la stack main. Et donc les arguments de printf() dans les adresses hautes seront collés aux variables de la stack parents ce qui fait que ce qu'il y a après l'argument, pourra être touché par printf() en croyant qu'il touche à des arguments (dans le screen, les adresses hautes sont vers le haut. d'ailleurs je crois qu'il s'est planté pour fmt_string, ca devrais être "%5$p")
![Pasted image 20240229161729.png](https://github.com/PavelSmerdiakov/Security-Notes/blob/main/Pasted%20image%2020240229161729.png)
- **Exploitation**
	- Bon déjà on sait pas de base où se trouve notre string (input). On va donc chercher dans toute la pile pour la retrouver :
		- `for((i=1;i<1000;i++)); do echo -n "$i " && ./vuln "AAAABBBB%$i\x" 0; done | grep 4141`  Technique trouvé dans un livre mais ca marche pas
		- `for ((i = 1; i < 1000; i++)); do echo -n "\n $i " && ./chiendlacasse "AAAABBBB%$i\$p  " 0; done | grep 414141` et quand tu trouve les 414141, tu regarde le i :
		- `./chiassefroc "$(python -c 'print("AAAABBBBCCCCDDDD %186$p %187$p %188$p")')"` avec à la place des 186, 187, les valeurs que t'as trouvées.
		- Essaye de faire en sorte de bien contrôler 8 octet aligné sur un paramètre sinon c'est chiant. Pour ça, étant donné qu'on est en little-indian, les 8 premier octet de ton payload seront ton adresse, et pour aligner t'incrémente en ajoutant un B derrière. Quand tout tes A sont sur la même adresse, tu touche plus. Dans le payload final tu devra prendre en compte les B que tu met derrière pour correctement écrire.
	- Ensuite, faut chercher l'adresse de target donc on utilise gdb :
		- `disas vuln` et tu regardes quel endroit de la pile reçoit un byte 0x0
		- Après tu place un breakpoint après que la valeur reçoit 0x0, tu lances puis t'inspectes cette adresse relative (`x/x $rbp-0x4` par exemple). Tu vas donc confirmer que c'est le bon endroit en voyant que la valeur est 0x0 puis tu regardes l'adresse absolue.
	- Dès qu'on a cette adresse, on peut donc l'exploiter. On va donc utiliser %n qui lui prend en argument un pointeur vers un int. Nous on lui fournit pas d'arguments donc en fait il va prendre des valeurs qui sont sur la pile, c'est pour ça qu'on a trouver le %186 c'est que c'est l'emplacement de notre input donc si %n regarde cette adresse, il va donc aller à l'adresse qui est indiqué par notre input (pas l'adresse mémoire réel mais la valeur) et va écrire à ce nouvel endroit indiqué, le nombre de byte écrit dans l'output.
	- Pour pouvoir écrire ce qu'on veut où on veut (ça pourrait être une variable qui contient un password et donc si on change le password qui est utilisé pour comparer l'input, on a juste à changer cette variable et la faire coincider avec notre password input), on va utiliser des %5x où 5 va être la valeur qui permet d'écrire ce qu'on veut.
	- Imaginons qu'on veuille écrire **080484cb** dans l'adresse *0x080498ac*, on le sépare en deux pour avoir 0804 (2052 en décimal) en high order byte et 84cb (33995 en décimal) en low order byte. On fait ça pour optimiser le temps je crois. Étant donné qu'on est en little-indian, on va devoir écrire 0804 en premier. On fait donc 2052 - les bytes qui sont déjà écrit avec l'adresse, le décalage (12 par exemple) ce qui nous donne 2040. Pareil pour l'autre : 33995 - 2052 (les bytes déjà écrits) = 31943.
	- On a donc notre payload qui va ressembler à \\xac\\x98\\x04\\x08\\xae\\x98\\x04\\x08BBBB%2040x%186$hn%31943x%187\$hn
	- Explication : La première adresse écrite c'est celle qu'on a trouvé pour mettre les bytes high order (0804) dans l'espace le plus à gauche de la mémoire (car plus ça descend/va vers la droite, plus l'adresse est haute). Et donc à cette endroit là (l'adresse écrite dans le premier arguments qu'on touche avec %n qui est donc la première adresse), on marque le nombre de bytes écrits. On utilise %hn pour écrire 2 octet, d'où le fait qu'on divise l'adresse en deux. Pour l'autre adresse, c'est \\xae car on se décale de 2 octet vers le haut (l'espace mémoire le plus à droite dans l'espace mémoire cible).
	- On a donc réussi à écrire ce qu'on voulait dans une variable.
- **Pense bête / Variantes**
	- C'est possible que la variable dans laquelle on veut écrire se trouve en dehors de main donc de la stack. Mais elle est simplement dans le segment bss. Si on veut voir l'adresse de la variable target :
		- `objdump -t ./format1 | grep target`
	- Dans l'écriture de la valeur qu'on voulait dans l'adresse cible, là c'est simple car la valeur des high order bytes sont plus petits. Par contre s'ils sont plus grands, c'est une autre méthode.
 
![Pasted image 20240301225307.png](https://github.com/PavelSmerdiakov/Security-Notes/blob/main/Pasted%20image%2020240301225307.png)


 Y'a pas mal de truc qu'on peut faire avec cet vulnérabilité :
 
		- Overwrite the saved return address. To do this, we must work out the address of the saved return address, which means guesswork, brute force, or information disclosure.
		- Overwrite another application-specific function pointer. This technique is unlikely to be easy since many programs don’t leave function pointers available to you. However, you might find something useful if your target is a C++ application.
		- Overwrite a pointer to an exception handler, then cause an exception. This is extremely likely to work, and involves eminently guessable addresses.
		- Overwrite a GOT entry. We did this in wu-ftpd. This is a pretty good option.
		- Overwrite the atexit handler. You may or may not be able to use this technique depending on the target.
		- Overwrite entries in the DTORS section. For this technique, see the paper by Juan M. Bello Rivas in the bibliography.
		- Turn a format string bug into a stack or heap overflow by overwriting a null terminator with non-null data. This is tricky, but the results can be quite funny.
		- Write application-specific data such as stored UID or GID values with values of your choice.
		- Modify strings containing commands to reflect commands of your choice. If we can’t run code on the stack, we can easily bypass the problem by the following:
			- Writing shellcode to the location of your choice in memory, using %n- type specifiers. We did this in our wu-ftpd example.
			- Using a register-relative jump if we’re brute forcing, which gives us a much better chance of hitting our shellcode (if it’s in our format string).
