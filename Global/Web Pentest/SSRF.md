**Une SSRF consiste √† faire demander au serveur cible une donn√©e, une page ou autre qui se situe c√¥t√© serveur. Cela permet de voir des informations avec les droits du serveur plut√¥t qu'avec les droits d'un utilisateur quelconque.**

---

**Cheat sheet :**

- [https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass "https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass")
- **localhost :**
    - [http://localhost](http://localhost "http://localhost")
    - üîπ[http://127.1](http://127.1 "http://127.1")
    - üîπ[http://127.0.0.0](http://127.0.0.0 "http://127.0.0.0")
    - üîπ[http://127.0.0.1](http://127.0.0.1 "http://127.0.0.1")
    - üîπ[http://2130706433](http://2130706433 "http://2130706433")
    - üîπ[http://0177.1](http://0177.1 "http://0177.1")
    - üîπ[http://0x7f.1](http://0x7f.1 "http://0x7f.1")
    - üîπ[http://127.000.000.1](http://127.000.000.1 "http://127.000.000.1")
    - üîπ[http://localtest.me](http://localtest.me "http://localtest.me")
    - üîπhttp://[::1]
    - üîπhttp://[::]

---

**Th√©orie/Technique :**  
**Technique de base :**

- L'application demande une ressource interne avec une requ√™te http. Pour exploiter cela, on peut modifier le lien de la requ√™te pour y mettre un lien interne int√©ressant. Requ√™te de base : blablabla... Stockapi=[https://stockblablalienonsenfout](https://stockblablalienonsenfout "https://stockblablalienonsenfout") Injection : Stockapi=[https://localhost/admin](https://localhost/admin "https://localhost/admin")

**Blacklist :**

- On urlencode ou double urlencode (par exemple, tu prends 'a', tu regardes sa repr√©sentation en hex dans la table ascii, puis tu urlencode le r√©sultat ce qui donnera %2561)
- Utiliser http ou https si on redirige vers un endroit qu'on contr√¥le
- On met le 127.0.0.1 en binaire
- Regarde la cheat sheet localhost.

**Whitelist :**

- **Utiliser un faux param√®tre :**
    - Injection : [https://expected-host:fakepassword@evil-host](https://expected-host:fakepassword@evil-host "https://expected-host:fakepassword@evil-host"). Le fakepassword ne sera pas pris en compte, mais le evil host si.
- **Utiliser le # de section :**
    - Injection : [https://evil-host#expected-host](https://evil-host#expected-host "https://evil-host#expected-host"). C'est simple, le site voit le lien attendu dans une section donc il y va. M√™me si la section n'existe pas dans notre evil host, on y va quand m√™me.
- **Utiliser la hi√©rarchie DNS :**
    - Injection : [https://expected-host.evil-host](https://expected-host.evil-host "https://expected-host.evil-host")
- **Urlencode ou double urlencode.**

**  
**  
**Blind SSRF :**  
[https://portswigger.net/web-security/ssrf/blind](https://portswigger.net/web-security/ssrf/blind "https://portswigger.net/web-security/ssrf/blind")

---

**Exploitation :**  
**R√©cup√©ration de donn√©es internes :**

- **Utilisation de double urlencode, param√®tre (@) dans un contexte de whitelist :**
    
    1. Injection : stockApi=[http://localhost%2523@stock.weliketoshop.net/admin/delete?username=carlos](http://localhost%2523@stock.weliketoshop.net/admin/delete?username=carlos "http://localhost%2523@stock.weliketoshop.net/admin/delete?username=carlos")
        
    2. Explication step by step (sbs) :
        
    3. On test d'abord de mettre stockApi=[http://localhost](http://localhost "http://localhost") pour voir si on nous oblige un domaine (oui et c'est stock.weliketoshop.net dans ce cas).
        
    4. On peut alors tester plusieurs trucs. Dans mon cas, ce qui a march√© c'est l'utilisation de param√®tre avec '@'. J'ai donc j'ai stockApi=[http://username@stock](http://username@stock "http://username@stock")... ce qui nous rend une erreur 500.
        
    5. On ajoute un # pour avoir stockApi=[http://username#@stock.weliketoshop.net](http://username#@stock.weliketoshop.net "http://username#@stock.weliketoshop.net") et on a une erreur qui nous dit que l'host doit etre stock.weblabla. C'est donc int√©ressant car √ßa veut dire que le # est pris en compte et donc le server va chercher √† username dans la section #.
        
    6. On tente alors d'urlencode le # (dans burp repeater) donc %23. Toujours la m√™me erreur. Maintenant, on double urlencode donc on select %23 puis CTRL + U. Cette fois ci, on a une erreur 500 donc ca veut dire que le stock.weli... est pris en compte dans la whitelist pour bypass les filtres mais quand on veut acc√©der √† la ressource, le # se r√©v√®le et donc le stock.we... est pris en compte comme un fragment ce qui le rend invisible puisqu'il n'existe pas.
        
    7. Maintenant, on a plus qu'√† sp√©cifier o√π on veut aller ce qui nous ram√®ne √† l'injection finale. Le fait que localhost et /admin... est s√©par√© √ßa peut paraitre bizarre mais c'est normale c'est juste que c'est une url donc on doit respecter √ßa :
        

![url.jpg](file:///home/wpkaliuser/.config/joplin-desktop/resources/24737c9804061243d05f747f5ddc73b6.jpg)

- **Switch de path gr√¢ce √† une autre requ√™te :**
    
    1. Injection (pas le plus int√©ressant) : stockApi=/product/nextProduct%3fcurrentProductId%3d1%26path%3dhttp%3a//192.168.0.12%3a8080/admin
        
    2. Explication sbs :
        
    3. On a une fonctionnalit√© qui, dans sa requ√™te http, contient un param√®tre stockApi qui lui contient simplement un path urlencod√©. C'est donc une r√©cup√©ration de donn√©es. On teste des ssrf dedans mais √ßa marche pas. Dans l'application, y'a une autre fonctionnalit√© qui elle contient dans la requete http GET /product/nextProduct?currentProductId=1&path=/prodonsenfout.¬† C'est donc une redirection o√π on r√©cup√®re la donn√©es qui est dans le path car il est d√©clar√© un peu comme valeur de productid=1 en fait. Donc en cherchant le productid=1, on va o√π on veut.
        
    4. On teste de mettre www.google.com √† la place du path et on est redirig√©. Par contre, quand on met un path interne qu'on veut ([http://192.168.0.12:8080/admin/delete?username=carlos](http://192.168.0.12:8080/admin/delete?username=carlos "http://192.168.0.12:8080/admin/delete?username=carlos") dans mon cas), ca marche pas.
        
    5. Maintenant qu'on connait un url valide pour r√©cup√©rer une donn√©es internes, on est le roi du p√©trole. On peut juste mettre la requete /product/nextProduct?currentProductId=1&path=/prodonsenfout avec le path qu'on veut, l'urlencoder et ca fonctionnera.
        
    6. Pourquoi √ßa fonctionne ? Parce qu'on a un url valide. A la base, on sait pas comment r√©cup√©rer une donn√©e sur le server juste avec le param√®tre stockApi car c'est juste un chemin pourri. Mais gr√¢ce √† une autre fonctionnalit√©, on a pu savoir comment chopper une donn√©e interne. Faut retenir que m√™me si y'a un truc du genre qui marche pas dans une certaine fonctionnalit√©, bah on peut utiliser un √©l√©ment de la requ√™te pour le mettre dans une autre requ√™te. C'est plus de la cr√©ativit√© que de la technique l√†.