## Définition : 

**Broken Access Control** : C'est quand un utilisateur fait une action qu'il n'est pas censé pouvoir faire.

**Horizontal privesc** : Si t'es simple user, tu peux avoir accès aux données des autres simples users.

**Vertical privesc **: Si t'es simple user, tu peux avoir accès aux données de qui tu veux.

**Access control security models** : Ensemble des techniques et des couches permettant d'installer des règles. Ils sont non seulement implémenter dans les applications et les server web, mais également dans les network, os, db management system et dans les back office.

**IDOR** : Les IDOR c'est une forme de BAC où tous se passe généralement dans les header de requêtes http. C'est souvent via les méthodes http, les paramètres, des objects ou autres. Exemple :

- GET /invoice.php?id=12
- POST /personalInfo.php
- {personId:23,name:”tester”}
- GET /invoices/1234.txt

**Static files**: Fichiers un peu tous sous la même forme mais différents dans le contenu (log de discussion par exemple) que le server va leur incrémenter le nom. 1.txt, 2.txt...

**Multi-step process** : Séries d'étape pour faire une action. On peut penser à un changement de mot de passe ou de rôle.

---

### How to prevent access control vulnerabilities :

Access control vulnerabilities can be prevented by taking a defense-in-depth approach and applying the following principles:

- Never rely on obfuscation alone for access control.
- Unless a resource is intended to be publicly accessible, deny access by default.
- Wherever possible, use a single application-wide mechanism for enforcing access controls.
- At the code level, make it mandatory for developers to declare the access that is allowed for each resource, and deny access by default.
- Thoroughly audit and test access controls to ensure they work as designed.

---

### Access control security models :  

**Programmatic access control :**

- C'est quand y'a des matrices d'users qui sont stockées dans les db et sont donc référencées dans les programmes facilement. C'est un modèle "highly granular" ce qui signifie que les règles  d'acces et de controle sont précis et détaillé mais peuvent être appliquées à des groupes. En gros c'est juste la logique de la db.

**Discretionary access control (DAC) :**

- Ce modèle consiste à ce que les propriétaires des ressources (donc admin ou utilisateurs dans un blog par exemple) décident de qui peut avoir accès à la ressource. C'est encore une fois un modèle "highly granular" puisqu'on pourra généralement choisir un groupe d'utilisateurs qui peuvent accéder à la donnée. Par contre, c'est assez manuel donc peut devenir rapidement complexe et chiant à gérer.

**Mandatory access control (MAC) :**

- Dans ce modèle, c'est le système qui choisit automatiquement qui peut voir la ressource. Même l'owner de la ressource ne peut pas le changer. C'est également le modèle associé au modèles militaires.

**Role-Based access control (RBAC) :**

- Dans ce modèle, des rôles sont attribuées dans lesquelles des fonctions pour chacun des rôles sont définies. Par exemple, un prof et un surveillant sont a peu près au même niveau mais n'ont pas les même fonctions possibles.

---

## Théorie/Technique :

###### Audit de code :

- **Déclaration de chemin caché :**
    - Le dev peut spécifier des chemins un peu caché dans le code source et donc on peut les retrouver.

###### Parameter-based :

- **Accès grâce à paramètre, cookie ou encore emplacement d'écriture caché :**
    - Des fois, l'accès d'une page se fait grâce à un paramètre, un emplacement d'écriture caché ou encore le cookie donc regarder si on peut l'influencer. Exemple :
	- [https://insecure-website.com/login/home.jsp?admin=true](https://insecure-website.com/login/home.jsp?admin=true "https://insecure-website.com/login/home.jsp?admin=true")
	- [https://insecure-website.com/login/home.jsp?role=1](https://insecure-website.com/login/home.jsp?role=1 "https://insecure-website.com/login/home.jsp?role=1")
	- Cela marche également quand les rôles sont données dans des requêtes xml ou json au server. Si on sait que par exemple quand on change d'adresse mail du compte, on envoie une requête json (qu'on peut découvrir en regardant la réponse dans burpsuite), on peut modifier cette requête en modifiant un paramètre qui pourrai nous donner de meilleurs privilèges.

###### HTTP Parameter Pollution (HPP) :

- **Définition et fonctionnement général :**
    - Les HPP exploitent l'ambiguïté des paramètres dupliqué dans une requêtes. Ca marche en fonction de comment le server gère ces paramètres. Y'en a qui pourrai concaténer les paramètre dupliqués, y'en a qui pourrai prendre que le dernier...

###### Application layer  misconfiguration :

- **Utilisation du header X-Original-URL :**
    - Si l'application interdit l'accès à un groupe ou un utilisateur mais autorise l'utilisation du header X-Original-URL, on peut bypass cette règle.

###### BAC thanks to IDOR :

- **Changement de valeur d'un objet :**
    - Si l'application appelle un objet de la db par exemple, on pourrait essayer de changer l'id de cet appel pour prendre changer l'objet de la colonne qu'on veut.

###### Multi-step process vuln :

- **Skip d'étape due à l'ignorence d'une étape dans le process :**
    - Parfois, les multi-step process créer un bon access control sur certaine étape mais en oublie une ou deux (ou plus, on s'en fout). On pourra donc appuyer sur ces points faibles pour skip toute la série d'étapes.

###### Referer based access control :

- **Changement du referer :**
    - Si l'application se base sur le referer pour savoir si tu es autorisé à accéder à la donnée, tu peux donc changer le referer dans burpsuite pour mettre celui autorisé.

###### Geo-located access control :

- **Fake location :**
    - C'est tout con faut juste utiliser un vpn, ou proxy, user-agent ou tout ce qui te permet de te changer d'identité.

---

## Exploitation :


###### HTTP Parameter Pollution (HPP) :

- **Le server utilise le dernier paramètre :**

    1. Requête de base : `[http://example.com/home?redirectURL=internalPage]`
    2. Injection : `http://example.com/home?redirectURL=internalPage&redirectURL=http://malicious.com`
    3. On va essayer d'écraser le premier paramètre avec le notre. Y'a rien d'autre à dire c'est juste une template d'injection en fait.
        
- **Le server concatène les paramètres :**
    
    1. Requête de base : `http://example.com/home?redirectURL=internalPage`
    2. Injection : `http://example.com/home?redirectURL=http://mal&redirectURL=icious.com`
    3. Pareil, rien à dire c'est simple.
        
- **HPP x XSS :**
    
    1. Injection : `http://127.0.0.1:631/admin/?kerberos=onmouseover=alert(1)&kerberos`
    2. On créer un paramètre kerberos qu'on va utiliser deux fois. Une fois pour mettre l'injection XSS et une deuxième fois pour avoir une valeur du paramètre valide (forcément valide car y'a rien dedans). Le paramètre va rester onmouseover=alert(1) du coup et l'injection XSS aura lieu quand la victime va sur le lien. On peut donc faire du phishing avec cette vulnérabilité.
        

###### Application layer  misconfiguration :


- **Utilisation du header X-Original-URL :**
    - Interdiction d'une page à un groupe/users :
        1. Injection : `GET /?username=carlos [...] X-Original-Url: /admin/delete`
            
        2. Première étape, si on veut charger une page mais qu'on a un accès refusé avec une forme un peu plaintext comme sur le screen, ca peut signifier un problème dans l'app layer.![[Pasted image 20240307144251.png]]
        3. Ensuite on va faire un petit test : on met le chemin / dans la requete GET et on ajoute le header X-Original-URL: /invalid. Si on a une erreur "Not found", ca signifie que le server utilise l'header x-original-url car normalement, / fonctionne tout seul.
        4. On peut donc mettre /admin dans l'header x-original-url et voir si ca fonctionne.
        5. Si on veut utiliser un paramètre ou autre, on peut faire l'injection finale : `GET /?username=carlos [...] X-Original-Url: /admin/delete` . L'header spécifie la page et la requete GET spécifie un paramètre.

- **Access control via la méthode http :**
    
    1. Des fois, y'a des access control qui se font via les méthode http (POST par exemple). Bah si on change la requête dans burpsuite (clique droit, change request method), on pourrai peut-être quand même accéder à la page.

 
###### Horizontal privesc :

- **Autoleak d'info pour horizontal privesc :**
    - Trop de données directement sur le navigateur :
        1. Des fois des données en trop sont données public. Imaginons qu'on ai un site blog où on peut aller sur le profil des autres. On peut chercher tout type d'info sur la page.
            
        2. On peut avoir l'id de l'utilisateur dans l'url ce qui pourrais nous aider à nous connecter à la cible.
            
    - Trop de données dans une réponse :
        
        1. Imaginons qu'on ai une application qui nous renvoie sur la page login quand on veut accéder à une page dont on n'a pas accès.
            
        2. Si on examine la réponse de cette requête non-authorisée dans burpsuite, on pourrai peut-être quand même la voir ou alors avoir des infos dessus.
            


###### Vertical privesc :

- **Horizontal to Vertical privesc :**
    - Trop de données dans une réponse :
        
        1. Bon bah c'est exactement comme dans l'horizontal mais avec un compte admin en target.

###### BAC thanks to IDOR :

- **Appel non filtré d'un objet de la database :**
    
    1. Requête de base : `https://insecure-website.com/customer_account?customer_number=132355`
    2. On pourrait simplement changer l'id (132355) de l'objet pour avoir la page d'un autre customer.
        
- **Utilisation de static files :**
    
    1. Imaginons qu'on ai une app de discussion qui nous permet de dl les logs de discussion mais qui utilise des static files.
        
    2. Dans burpsuite, on pourrai changer le nom du fichier qu'on va aller chercher sur le server. On peut car les noms sont incrémentés. Rappel car j'ai fait l'erreur : la requête qu'on va changer sera évidemment une requête GET.
        

###### Multi-step process vuln :

- **Pas de vérification final dans le process :**
    
    1. Imaginons un site dans lequel un admin peut changer le rôle des users. Le multi-step process se fait en 2 requêtes : l'action, la confirmation mais pas de vérification.
        
    2. On va prendre avantage du fait qu'il n'y a pas de vérification pour pouvoir changer la requête.
        
    3. On essaye de changer le cookie de première requête pour l'action pour pouvoir mettre le notre : (attention, c'est un lab de portswigger dans lequel on avait accès au compte admin donc on connaissait les requêtes)
        

![Screenshot_2023-10-17_18-16-29.png](file:///home/wpkaliuser/.config/joplin-desktop/resources/92bcea9c9d4b7dfa77270c72e53f3ccb.png)  
4. Ca ne fonctionne pas donc on va tenter dans la deuxième requête :  
![Screenshot_2023-10-17_18-17-50.png](file:///home/wpkaliuser/.config/joplin-desktop/resources/8c6589e68576d94a7392d7cd1ea281f2.png)


5. Bam, ca marche. Pourquoi ? C'est parce qu'il n'y a pas de vérification final. Si y'en aurait une, l'app aurait compris que le cookie n'est pas un cookie autorisé à faire ça et aurait donc rejeter la requête.


###### Referer based access control :

- **Changement du referer basique :**
    
    1. Bon y'a pas grand chose à dire c'est simple, faut juste trouver le bon referer (pas simple donc essaye du fuzz si t'as de la chatte)